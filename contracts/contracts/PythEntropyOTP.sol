// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@pythnetwork/entropy-sdk-solidity/IEntropy.sol";
import "@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol";

/**
 * @title PythEntropyOTP
 * @notice Generates secure OTPs using Pyth Network's Entropy service for OfflinePay SMS authentication
 * @dev This contract uses Pyth Entropy for verifiable randomness to generate 6-digit OTPs
 * 
 * Prize Track: Pyth Entropy ($1,000)
 * Use Case: Decentralized OTP generation for SMS-based DeFi authentication
 */
contract PythEntropyOTP is IEntropyConsumer {
    IEntropy public entropy;
    address public entropyProvider;
    address public owner;
    
    struct OTPRequest {
        address requester;
        string phoneNumber;
        uint64 sequenceNumber;
        uint256 timestamp;
        bool fulfilled;
        uint256 otp;
    }
    
    // Mappings
    mapping(uint64 => OTPRequest) public otpRequests;
    mapping(string => uint256) public latestOTP;
    mapping(string => uint256) public otpExpiry;
    mapping(string => uint256) public otpAttempts;
    
    // Constants
    uint256 public constant OTP_EXPIRY_SECONDS = 300; // 5 minutes
    uint256 public constant OTP_DIGITS = 6;
    uint256 public constant MAX_OTP_ATTEMPTS = 3;
    
    // Events
    event OTPRequested(
        uint64 indexed sequenceNumber,
        string phoneNumber,
        address requester,
        uint256 timestamp
    );
    
    event OTPGenerated(
        uint64 indexed sequenceNumber,
        string phoneNumber,
        uint256 otp,
        uint256 expiresAt
    );
    
    event OTPVerified(
        string indexed phoneNumber,
        bool success,
        uint256 timestamp
    );
    
    event OTPExpired(string indexed phoneNumber, uint256 timestamp);
    
    // Modifiers
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
    
    constructor(address _entropy, address _entropyProvider) {
        entropy = IEntropy(_entropy);
        entropyProvider = _entropyProvider;
        owner = msg.sender;
    }
    
    /**
     * @notice Request a new OTP for a phone number
     * @param phoneNumber The phone number to generate OTP for (E.164 format)
     * @param userRandomNumber User-provided random number for additional entropy
     * @return sequenceNumber The sequence number for this request
     */
    function requestOTP(
        string calldata phoneNumber,
        bytes32 userRandomNumber
    ) external payable returns (uint64) {
        require(bytes(phoneNumber).length > 0, "Phone number cannot be empty");
        
        // Check if previous OTP expired
        if (otpExpiry[phoneNumber] > 0 && block.timestamp >= otpExpiry[phoneNumber]) {
            emit OTPExpired(phoneNumber, block.timestamp);
            delete latestOTP[phoneNumber];
            delete otpExpiry[phoneNumber];
            otpAttempts[phoneNumber] = 0;
        }
        
        // Get fee for entropy request
        uint256 fee = entropy.getFee(entropyProvider);
        require(msg.value >= fee, "Insufficient fee");
        
        // Request random number from Pyth Entropy
        uint64 sequenceNumber = entropy.requestWithCallback{value: fee}(
            entropyProvider,
            userRandomNumber
        );
        
        // Store request
        otpRequests[sequenceNumber] = OTPRequest({
            requester: msg.sender,
            phoneNumber: phoneNumber,
            sequenceNumber: sequenceNumber,
            timestamp: block.timestamp,
            fulfilled: false,
            otp: 0
        });
        
        emit OTPRequested(sequenceNumber, phoneNumber, msg.sender, block.timestamp);
        
        // Refund excess payment
        if (msg.value > fee) {
            payable(msg.sender).transfer(msg.value - fee);
        }
        
        return sequenceNumber;
    }
    
    /**
     * @notice Callback function called by Pyth Entropy with random number
     * @param sequenceNumber The sequence number of the request
     * @param provider The entropy provider address
     * @param randomNumber The random number generated by Pyth
     */
    function entropyCallback(
        uint64 sequenceNumber,
        address provider,
        bytes32 randomNumber
    ) internal override {
        require(provider == entropyProvider, "Invalid provider");
        
        OTPRequest storage request = otpRequests[sequenceNumber];
        require(!request.fulfilled, "Already fulfilled");
        require(bytes(request.phoneNumber).length > 0, "Request not found");
        
        // Generate 6-digit OTP from random number
        // Use modulo to get a number between 0-999999, then ensure it's 6 digits
        uint256 otp = uint256(randomNumber) % (10 ** OTP_DIGITS);
        
        // Ensure OTP is always 6 digits (pad with leading zeros if needed)
        if (otp < 100000) {
            otp += 100000;
        }
        
        // Store OTP
        otpRequests[sequenceNumber].otp = otp;
        otpRequests[sequenceNumber].fulfilled = true;
        latestOTP[request.phoneNumber] = otp;
        
        uint256 expiresAt = block.timestamp + OTP_EXPIRY_SECONDS;
        otpExpiry[request.phoneNumber] = expiresAt;
        otpAttempts[request.phoneNumber] = 0;
        
        emit OTPGenerated(sequenceNumber, request.phoneNumber, otp, expiresAt);
    }
    
    /**
     * @notice Get the latest OTP for a phone number
     * @param phoneNumber The phone number
     * @return otp The OTP (0 if expired or not generated)
     * @return isValid Whether the OTP is still valid
     * @return expiresAt When the OTP expires (0 if invalid)
     */
    function getOTP(string calldata phoneNumber) 
        external 
        view 
        returns (uint256 otp, bool isValid, uint256 expiresAt) 
    {
        otp = latestOTP[phoneNumber];
        expiresAt = otpExpiry[phoneNumber];
        isValid = block.timestamp < expiresAt && otp > 0;
        
        if (!isValid) {
            otp = 0;
            expiresAt = 0;
        }
    }
    
    /**
     * @notice Verify an OTP for a phone number
     * @param phoneNumber The phone number
     * @param otp The OTP to verify
     * @return valid Whether the OTP is valid
     */
    function verifyOTP(string calldata phoneNumber, uint256 otp) 
        external 
        returns (bool valid) 
    {
        // Check if OTP expired
        if (block.timestamp >= otpExpiry[phoneNumber]) {
            emit OTPExpired(phoneNumber, block.timestamp);
            delete latestOTP[phoneNumber];
            delete otpExpiry[phoneNumber];
            otpAttempts[phoneNumber] = 0;
            emit OTPVerified(phoneNumber, false, block.timestamp);
            return false;
        }
        
        // Check if too many attempts
        if (otpAttempts[phoneNumber] >= MAX_OTP_ATTEMPTS) {
            emit OTPVerified(phoneNumber, false, block.timestamp);
            return false;
        }
        
        // Verify OTP
        valid = latestOTP[phoneNumber] == otp && otp > 0;
        
        if (valid) {
            // Clear OTP after successful verification
            delete latestOTP[phoneNumber];
            delete otpExpiry[phoneNumber];
            otpAttempts[phoneNumber] = 0;
        } else {
            // Increment failed attempts
            otpAttempts[phoneNumber]++;
        }
        
        emit OTPVerified(phoneNumber, valid, block.timestamp);
        return valid;
    }
    
    /**
     * @notice Get OTP request details by sequence number
     * @param sequenceNumber The sequence number
     * @return request The OTP request details
     */
    function getOTPRequest(uint64 sequenceNumber) 
        external 
        view 
        returns (OTPRequest memory) 
    {
        return otpRequests[sequenceNumber];
    }
    
    /**
     * @notice Get remaining attempts for a phone number
     * @param phoneNumber The phone number
     * @return remaining Number of attempts remaining
     */
    function getRemainingAttempts(string calldata phoneNumber) 
        external 
        view 
        returns (uint256 remaining) 
    {
        uint256 attempts = otpAttempts[phoneNumber];
        if (attempts >= MAX_OTP_ATTEMPTS) {
            return 0;
        }
        return MAX_OTP_ATTEMPTS - attempts;
    }
    
    /**
     * @notice Get the entropy address (required by IEntropyConsumer)
     */
    function getEntropy() internal view override returns (address) {
        return address(entropy);
    }
    
    /**
     * @notice Update entropy provider (owner only)
     * @param newProvider The new entropy provider address
     */
    function updateEntropyProvider(address newProvider) external onlyOwner {
        entropyProvider = newProvider;
    }
    
    /**
     * @notice Withdraw contract balance (owner only)
     */
    function withdraw() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
    
    /**
     * @notice Transfer ownership (owner only)
     * @param newOwner The new owner address
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid new owner");
        owner = newOwner;
    }
    
    receive() external payable {}
}

