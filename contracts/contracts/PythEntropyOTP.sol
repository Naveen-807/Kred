// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@pythnetwork/entropy-sdk-solidity/IEntropy.sol";
import "@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol";

/**
 * @title PythEntropyOTP
 * @notice Generates secure OTPs using Pyth Network's Entropy service
 * @dev This contract uses Pyth Entropy for verifiable randomness
 */
contract PythEntropyOTP is IEntropyConsumer {
    IEntropy public entropy;
    address public entropyProvider;
    
    struct OTPRequest {
        address requester;
        string phoneNumber;
        uint64 sequenceNumber;
        uint256 timestamp;
        bool fulfilled;
        uint256 otp;
    }
    
    mapping(uint64 => OTPRequest) public otpRequests;
    mapping(string => uint256) public latestOTP;
    mapping(string => uint256) public otpExpiry;
    
    uint256 public constant OTP_EXPIRY_SECONDS = 300; // 5 minutes
    uint256 public constant OTP_DIGITS = 6;
    
    event OTPRequested(uint64 indexed sequenceNumber, string phoneNumber, address requester);
    event OTPGenerated(uint64 indexed sequenceNumber, string phoneNumber, uint256 otp);
    
    constructor(address _entropy, address _entropyProvider) {
        entropy = IEntropy(_entropy);
        entropyProvider = _entropyProvider;
    }
    
    /**
     * @notice Request a new OTP for a phone number
     * @param phoneNumber The phone number to generate OTP for
     * @param userRandomNumber User-provided random number for additional entropy
     * @return sequenceNumber The sequence number for this request
     */
    function requestOTP(
        string calldata phoneNumber,
        bytes32 userRandomNumber
    ) external payable returns (uint64) {
        // Get fee for entropy request
        uint256 fee = entropy.getFee(entropyProvider);
        require(msg.value >= fee, "Insufficient fee");
        
        // Request random number from Pyth Entropy
        uint64 sequenceNumber = entropy.requestWithCallback{value: fee}(
            entropyProvider,
            userRandomNumber
        );
        
        // Store request
        otpRequests[sequenceNumber] = OTPRequest({
            requester: msg.sender,
            phoneNumber: phoneNumber,
            sequenceNumber: sequenceNumber,
            timestamp: block.timestamp,
            fulfilled: false,
            otp: 0
        });
        
        emit OTPRequested(sequenceNumber, phoneNumber, msg.sender);
        
        return sequenceNumber;
    }
    
    /**
     * @notice Callback function called by Pyth Entropy
     * @param sequenceNumber The sequence number of the request
     * @param randomNumber The random number generated by Pyth
     */
    function entropyCallback(
        uint64 sequenceNumber,
        address,
        bytes32 randomNumber
    ) internal override {
        OTPRequest storage request = otpRequests[sequenceNumber];
        require(!request.fulfilled, "Already fulfilled");
        
        // Generate 6-digit OTP from random number
        uint256 otp = uint256(randomNumber) % (10 ** OTP_DIGITS);
        
        // Ensure OTP is 6 digits (pad with leading zeros if needed)
        if (otp < 100000) {
            otp += 100000;
        }
        
        // Store OTP
        request.otp = otp;
        request.fulfilled = true;
        latestOTP[request.phoneNumber] = otp;
        otpExpiry[request.phoneNumber] = block.timestamp + OTP_EXPIRY_SECONDS;
        
        emit OTPGenerated(sequenceNumber, request.phoneNumber, otp);
    }
    
    /**
     * @notice Get the latest OTP for a phone number
     * @param phoneNumber The phone number
     * @return otp The OTP (0 if expired or not generated)
     * @return isValid Whether the OTP is still valid
     */
    function getOTP(string calldata phoneNumber) external view returns (uint256 otp, bool isValid) {
        otp = latestOTP[phoneNumber];
        isValid = block.timestamp < otpExpiry[phoneNumber];
        
        if (!isValid) {
            otp = 0;
        }
    }
    
    /**
     * @notice Verify an OTP for a phone number
     * @param phoneNumber The phone number
     * @param otp The OTP to verify
     * @return valid Whether the OTP is valid
     */
    function verifyOTP(string calldata phoneNumber, uint256 otp) external view returns (bool) {
        return latestOTP[phoneNumber] == otp && block.timestamp < otpExpiry[phoneNumber];
    }
    
    /**
     * @notice Get the entropy address
     */
    function getEntropy() internal view override returns (address) {
        return address(entropy);
    }
    
    /**
     * @notice Withdraw contract balance (owner only)
     */
    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
    }
    
    receive() external payable {}
}
